{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","require","install","coreModbusQueue","internalDebugLog","node","registerType","removeModbusQueueActionsFromNode","config","mbBasics","createNode","this","name","topic","unitid","lowLowLevel","parseInt","lowLevel","ModbusQueueInfo","nodes","highLevel","highHighLevel","errorOnHighLevel","queueReadIntervalTime","showStatusActivities","updateOnAllQueueChanges","updateOnAllUnitQueues","setNodeStatusTo","updateStatusRrunning","getNode","server","unitsWithQueue","modbusClient","registerForModbus","initUnitQueueStates","unit","set","unitWithQueue","get","lowLowLevelReached","lowLevelReached","highLevelReached","highHighLevelReached","bufferCommandListLength","msg","checkLowLevelReached","state","checkHighLevelReached","now","modbusClientName","id","payload","Date","Error","warn","error","checkHighHighLevelReached","fillColor","getStatusSituationFillColor","setNodeStatusByActivity","status","fill","readFromQueue","Promise","resolve","reject","bufferCommandList","length","bufferCommands","checkQueueStates","resetStates","readFromAllUnitQueues","err","eventCallback","on","queueReadInterval","setInterval","removeListener","unitId","registerModbusQueueActionsToNode","allQueueData","queues","msgUnitId","resetQueue","queueOptions","date","queueEnabled","initQueue","settings","verbose","infoText","lowlowLevel","shape","msgQueueReset","send","done","text","deregisterForModbus","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid) || 1\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\n    this.showStatusActivities = config.showStatusActivities\n    this.updateOnAllQueueChanges = config.updateOnAllQueueChanges\n    this.updateOnAllUnitQueues = config.updateOnAllUnitQueues\n\n    this.internalDebugLog = internalDebugLog\n\n    const node = this\n    node.queueReadInterval = null\n    node.updateStatusRrunning = false\n    node.unitsWithQueue = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n\n    node.initUnitQueueStates = function () {\n      for (let unit = 0; unit < 256; unit += 1) {\n        node.unitsWithQueue.set(unit, {})\n        node.resetStates(unit)\n      }\n    }\n\n    node.resetStates = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      unitWithQueue.lowLowLevelReached = true\n      unitWithQueue.lowLevelReached = false\n      unitWithQueue.highLevelReached = false\n      unitWithQueue.highHighLevelReached = false\n    }\n\n    node.initUnitQueueStates()\n\n    node.checkLowLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLevelReached && bufferCommandListLength > node.lowLowLevel && bufferCommandListLength < node.lowLevel) {\n        unitWithQueue.lowLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'low level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          bufferCommandListLength: bufferCommandListLength\n        }\n        node.send(msg)\n      }\n    }\n\n    node.checkHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highLevelReached &&\n        bufferCommandListLength > node.lowLevel &&\n        bufferCommandListLength > node.highLevel) {\n        unitWithQueue.highLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          bufferCommandListLength: bufferCommandListLength\n        }\n\n        if (node.errorOnHighLevel) {\n          node.error(new Error('Queue High Level Reached'), msg)\n        } else {\n          node.warn(msg)\n        }\n\n        node.send(msg)\n      }\n    }\n\n    node.checkHighHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highHighLevelReached &&\n        bufferCommandListLength > node.highLevel &&\n        bufferCommandListLength > node.highHighLevel) {\n        unitWithQueue.highHighLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          highHighLevel: node.highHighLevel,\n          bufferCommandListLength: bufferCommandListLength\n        }\n        node.error(new Error('Queue High High Level Reached'), msg)\n        node.send(msg)\n      }\n    }\n\n    node.getStatusSituationFillColor = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      let fillColor = 'blue'\n\n      if (unitWithQueue.lowLevelReached) {\n        fillColor = 'green'\n      }\n\n      if (unitWithQueue.highLevelReached) {\n        if (node.errorOnHighLevel) {\n          fillColor = 'red'\n        } else {\n          fillColor = 'yellow'\n        }\n      }\n\n      if (unitWithQueue.highHighLevelReached) {\n        fillColor = 'red'\n      }\n\n      return fillColor\n    }\n\n    node.setNodeStatusByActivity = function (bufferCommandListLength, unit) {\n      if (node.showStatusActivities) {\n        node.status({\n          fill: node.getStatusSituationFillColor(node.unitid),\n          shape: 'ring',\n          text: (bufferCommandListLength) ? 'active unit ' + unit + ' queue items: ' + bufferCommandListLength : 'active (Unit-Id: ' + unit + ') empty'\n        })\n      }\n    }\n\n    node.readFromQueue = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n      const unit = ((node.unitid < 1 || node.unitid > 255)) ? 1 : node.unitid\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              const bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n              node.checkQueueStates(bufferCommandListLength, unit)\n              node.setNodeStatusByActivity(bufferCommandListLength, unit)\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      } else {\n        if (node.showStatusActivities) {\n          node.setNodeStatusByActivity(null, unit)\n        }\n      }\n    }\n\n    node.checkQueueStates = function (bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLowLevelReached && bufferCommandListLength < node.lowLowLevel) {\n        node.resetStates(unit)\n      }\n      node.checkLowLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighHighLevelReached(node, bufferCommandListLength, unit)\n    }\n\n    node.readFromAllUnitQueues = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              let bufferCommandListLength = 0\n              for (let unit = 0; unit < 256; unit += 1) {\n                bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n                if (!bufferCommandListLength) {\n                  continue\n                }\n                node.checkQueueStates(bufferCommandListLength, unit)\n              }\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      }\n    }\n\n    node.registerModbusQueueActionsToNode = function (eventCallback) {\n      if (node.updateOnAllQueueChanges) { // much more CPU-Load on many parallel requests to the client\n        modbusClient.on('mbqueue', eventCallback) // en-queue\n      }\n      modbusClient.on('mbactive', eventCallback) // de-queue\n      modbusClient.on('mbinit', eventCallback)\n      modbusClient.on('mbconnected', eventCallback)\n      modbusClient.on('mberror', eventCallback)\n      modbusClient.on('mbclosed', eventCallback)\n      node.queueReadInterval = setInterval(eventCallback, node.queueReadIntervalTime)\n    }\n\n    node.removeModbusQueueActionsFromNode = function (eventCallback) {\n      modbusClient.removeListener('mbqueue', eventCallback)\n      modbusClient.removeListener('mbactive', eventCallback)\n      modbusClient.removeListener('mbinit', eventCallback)\n      modbusClient.removeListener('mbconnected', eventCallback)\n      modbusClient.removeListener('mberror', eventCallback)\n      modbusClient.removeListener('mbclosed', eventCallback)\n    }\n\n    if (node.updateOnAllUnitQueues) {\n      node.registerModbusQueueActionsToNode(node.readFromAllUnitQueues)\n      mbBasics.setNodeStatusTo('active for all queues', node)\n    } else {\n      node.registerModbusQueueActionsToNode(node.readFromQueue)\n    }\n\n    node.on('input', function (msg) {\n      let msgUnitId = node.unitid\n      if (msg.payload.resetQueue) {\n        msgUnitId = parseInt(msg.payload.unitId)\n      } else {\n        msgUnitId = parseInt(msg.payload) || node.unitid\n      }\n      msg.payload = {}\n      msg.payload.queueEnabled = modbusClient.bufferCommands\n\n      if (node.updateOnAllUnitQueues) {\n        msg.payload.allQueueData = true\n        msg.payload.queues = modbusClient.bufferCommandList\n      } else {\n        msg.payload.allQueueData = false\n        msg.payload.unitid = msgUnitId\n        msg.payload.queue = modbusClient.bufferCommandList.get(msgUnitId)\n      }\n\n      msg.payload.queueOptions = {\n        date: Date.now(),\n        state: 'queue request',\n        modbusClientName: modbusClient.name || modbusClient.id,\n        lowlowLevel: node.lowlowLevel,\n        unitId: msgUnitId,\n        lowLevel: node.lowLevel,\n        highLevel: node.highLevel,\n        highHighLevel: node.highHighLevel\n      }\n\n      const msgQueueReset = msg.payload.resetQueue || msg.resetQueue\n      if (msgQueueReset && modbusClient.bufferCommands) {\n        coreModbusQueue.initQueue(modbusClient)\n        if (RED.settings.verbose) {\n          const infoText = 'Init Queue By External Node'\n          modbusClient.warn(infoText)\n          internalDebugLog(infoText)\n        }\n        node.initUnitQueueStates()\n\n        if (node.showStatusActivities) {\n          node.status({\n            fill: 'blue',\n            shape: 'ring',\n            text: 'active empty unit queue'\n          })\n        }\n        msg.payload.queueOptions.state = 'queue reset done'\n      }\n\n      node.send(msg)\n    })\n\n    node.on('close', function (done) {\n      if (node.updateOnAllUnitQueues) {\n        node.removeModbusQueueActionsFromNode(node.readFromAllUnitQueues)\n      } else {\n        node.removeModbusQueueActionsFromNode(node.readFromQueue)\n      }\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}