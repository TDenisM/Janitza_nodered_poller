{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","require","install","coreModbusClient","coreModbusQueue","nodes","registerType","config","createNode","this","serialConnectionDelayTimeMS","unlimitedListeners","defaultUnitId","clienttype","undefined","timeoutTimeMS","logHintText","bufferCommands","parallelUnitIdsAllowed","stateLogEnabled","tcpHost","tcpPort","parseInt","tcpType","serialBaudrate","serialStopbits","serialPort","serialDatabits","serialConnectionDelay","serialParity","serialType","commandDelay","clientTimeout","unit_id","reconnectTimeout","reconnectOnTimeout","node","verboseWarn","logMessage","serverInfo","verbose","warn","settings","internalDebug","isFirstInitOfConnection","closingModbus","Map","client","bufferCommandList","messagesAllowedStates","sendingAllowed","messageAllowedStates","stateMachine","createStateMachineService","stateService","initialState","actualServiceState","actualServiceStateBefore","reconnectTimeoutId","internalDebugLog","setDefaultUnitId","ModbusClientNode","setUnitIdFromPayload","msg","getActualUnitId","unitId","checkUnitId","verboseLog","queueLogEnabled","state","value","matches","updateServerinfo","initQueue","setTimeout","connectClient","err","payload","emit","queueSerialUnlockCommand","send","serialSendingAllowed","queueSerialLockCommand","close","message","ModbusRTU","error","Error","connectC701","port","setTCPConnected","modbusTcpErrorHandling","connectTelnet","autoOpen","setTCPConnectionOptions","connectTcpRTUBuffered","connectTCP","serialPortOptions","baudRate","dataBits","stopBits","then","setSerialConnectionOptions","modbusSerialErrorHandling","parity","connectRTUBuffered","setID","connectRTU","modbusSerialDebug","openSerialClient","JSON","stringify","errno","networkErrors","includes","modbusErrorHandling","showErrors","on","onModbusClose","cberr","indexOf","_port","pushToQueueByUnitId","readModbus","cb","queueLength","get","queueUnitId","length","queueLog","writeModbus","info","activateSending","checkQueuesAreEmpty","resolve","setNewNodeSettings","reject","done","nodeIdentifierName","name","id","mbBasics","clientUserNodeId","registeredNodeList","setStoppedState","closeConnectionWithoutRegisteredNodes","registerForModbus","Object","keys","deregisterForModbus","httpAdmin","auth","needsPermission","req","res","list","ports","json"],"mappings":"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","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:config:client')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const defaultTcpUnitId = 0\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n\n    this.unit_id = parseInt(config.unit_id)\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messagesAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n    node.internalDebugLog = internalDebugLog\n\n    coreModbusQueue.queueSerialLockCommand(node)\n\n    node.setDefaultUnitId = function () {\n      if (this.clienttype === 'tcp') {\n        node.unit_id = defaultTcpUnitId\n      } else {\n        node.unit_id = defaultUnitId\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.setDefaultUnitId()\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.setDefaultUnitId()\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose) {\n        node.warn('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (!state.value || node.actualServiceState.value === undefined) {\n        // verboseWarn('fsm ignore invalid state')\n        return\n      }\n\n      if (node.actualServiceStateBefore.value === node.actualServiceState.value) {\n        // verboseWarn('fsm ignore equal state ' + node.actualServiceState.value + ' after ' + node.actualServiceStateBefore.value)\n        return\n      }\n\n      if (state.matches('init')) {\n        verboseWarn('fsm init state after ' + node.actualServiceStateBefore.value)\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            verboseWarn('first fsm init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            verboseWarn('fsm init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        verboseWarn('fsm connected after state ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        if (node.clienttype === 'tcp') {\n          node.stateService.send('SEND')\n        } else {\n          if (node.serialSendingAllowed) {\n            coreModbusQueue.queueSerialLockCommand(node)\n            node.stateService.send('SEND')\n          }\n        }\n      }\n\n      if (state.matches('sending')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbopen')\n      }\n\n      if (state.matches('switch')) {\n        node.emit('mbswitch')\n        node.stateService.send('CLOSE')\n      }\n\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        verboseWarn('fsm failed state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        verboseWarn('fsm broken state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        verboseWarn('fsm reconnect state after ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialLockCommand(node)\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      if (node.client) {\n        try {\n          node.client.close(function () {\n            verboseLog('connection closed')\n          })\n          verboseLog('connection close sent')\n        } catch (err) {\n          verboseLog(err.message)\n        }\n      }\n      node.client = null\n      node.client = new ModbusRTU()\n\n      if (!node.clientTimeout) {\n        node.clientTimeout = timeoutTimeMS\n      }\n\n      if (!node.reconnectTimeout) {\n        node.reconnectTimeout = reconnectTimeMS\n      }\n\n      if (node.clienttype === 'tcp') {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        switch (node.tcpType) {\n          case 'C701':\n            verboseLog('C701 port UDP bridge')\n            node.client.connectC701(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .then(node.setTCPConnected)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TELNET':\n            verboseLog('Telnet port')\n            node.client.connectTelnet(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          case 'TPC-RTU-BUFFERED':\n            verboseLog('TCP RTU buffered port')\n            node.client.connectTcpRTUBuffered(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n            break\n          default:\n            verboseLog('TCP port')\n            node.client.connectTCP(node.tcpHost, {\n              port: node.tcpPort,\n              autoOpen: true\n            }).then(node.setTCPConnectionOptions)\n              .catch(node.modbusTcpErrorHandling)\n        }\n      } else {\n        if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n          node.error(new Error('wrong unit-id serial (0..247)'), { payload: node.unit_id })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        if (!node.serialConnectionDelay) {\n          node.serialConnectionDelay = serialConnectionDelayTimeMS\n        }\n\n        if (!node.serialPort) {\n          node.error(new Error('wrong serial port'), { payload: node.serialPort })\n          node.stateService.send('FAILURE')\n          return\n        }\n\n        const serialPortOptions = {\n          baudRate: parseInt(node.serialBaudrate),\n          dataBits: parseInt(node.serialDatabits),\n          stopBits: parseInt(node.serialStopbits),\n          parity: node.serialParity,\n          autoOpen: false\n        }\n\n        switch (node.serialType) {\n          case 'ASCII':\n            verboseLog('ASCII port serial')\n            node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          case 'RTU':\n            verboseLog('RTU port serial')\n            node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n          default:\n            verboseLog('RTU buffered port serial')\n            node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n              .catch(node.modbusSerialErrorHandling)\n            break\n        }\n      }\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n      }\n\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n      }\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.messageAllowedStates.indexOf(state.value) === -1) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      coreModbusQueue.queueSerialUnlockCommand(node)\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      if (coreModbusClient.setNewNodeSettings(node, msg)) {\n        cb(msg)\n      } else {\n        cberr(new Error('Message Or Payload Not Valid'), msg)\n      }\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('SWITCH')\n    })\n\n    node.on('close', function (done) {\n      const nodeIdentifierName = node.name || node.id\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + nodeIdentifierName)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + nodeIdentifierName)\n      node.internalDebugLog('close node ' + nodeIdentifierName)\n      node.removeAllListeners()\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              verboseLog('Connection closed with error ' + nodeIdentifierName)\n            } else {\n              verboseLog('Connection closed well ' + nodeIdentifierName)\n            }\n            done()\n          })\n        } else {\n          verboseLog('connection was closed ' + nodeIdentifierName)\n          done()\n        }\n      } else {\n        verboseLog('Connection closed simple ' + nodeIdentifierName)\n        done()\n      }\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (clientUserNodeId) {\n      node.registeredNodeList[clientUserNodeId] = clientUserNodeId\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n      node.emit('mbregister', clientUserNodeId)\n    }\n\n    node.setStoppedState = function (clientUserNodeId, done) {\n      node.stateService.send('STOP')\n      node.emit('mbderegister', clientUserNodeId)\n      done()\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (clientUserNodeId, done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.setStoppedState(clientUserNodeId, done)\n            })\n          } else {\n            node.setStoppedState(clientUserNodeId, done)\n          }\n        } else {\n          node.setStoppedState(clientUserNodeId, done)\n        }\n      } else {\n        node.setStoppedState(clientUserNodeId, done)\n      }\n    }\n\n    node.deregisterForModbus = function (clientUserNodeId, done) {\n      try {\n        delete node.registeredNodeList[clientUserNodeId]\n        if (node.closingModbus) {\n          done()\n          node.emit('mbderegister', clientUserNodeId)\n        } else {\n          node.closeConnectionWithoutRegisteredNodes(clientUserNodeId, done)\n        }\n      } catch (err) {\n        verboseWarn(err.message + ' on de-register node ' + clientUserNodeId)\n        node.error(err)\n        done()\n      }\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      res.json([err.message])\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}