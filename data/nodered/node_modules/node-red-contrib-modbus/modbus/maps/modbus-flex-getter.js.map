{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","nodes","registerType","config","createNode","this","name","showStatusActivities","showErrors","internalDebugLog","useIOFile","ModbusFlexGetter","getNode","ioFile","useIOForPayload","connection","emptyMsgOnFail","node","keepMsgProperties","mbBasics","server","bufferMessageList","modbusClient","registerForModbus","onModbusReadDone","resp","msg","buildMessageWithIO","data","errorProtocolMsg","err","logMsgError","sendEmptyMsgOnFail","message","origMsg","setModbusError","onModbusReadError","emit","JSON","parse","payload","prepareMsg","parseInt","fc","unitid","address","quantity","isValidModbusMsg","isValid","Number","isInteger","error","messageId","getObjectId","value","on","origMsgInput","assign","client","Object","newMsg","buildNewMessageObject","set","buildNewMessage","inputMsg","setNodeStatusTo","actualServiceState","deregisterForModbus","clear","id","done","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:flex:getter')\n\n  function ModbusFlexGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n      node.emit('modbusFlexGetterNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      mbBasics.logMsgError(node, err, msg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusFlexGetterNodeError')\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg.payload === 'string') {\n        msg.payload = JSON.parse(msg.payload)\n      }\n\n      msg.payload.fc = parseInt(msg.payload.fc) || 3\n      msg.payload.unitid = parseInt(msg.payload.unitid)\n      msg.payload.address = parseInt(msg.payload.address) || 0\n      msg.payload.quantity = parseInt(msg.payload.quantity) || 1\n\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.payload.fc) &&\n              msg.payload.fc >= 1 &&\n              msg.payload.fc <= 4)) {\n        node.error('FC Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.address) &&\n            msg.payload.address >= 0 &&\n            msg.payload.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.quantity) &&\n            msg.payload.quantity >= 1 &&\n            msg.payload.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          value: msg.payload.value || msg.value,\n          unitid: msg.payload.unitid,\n          fc: msg.payload.fc,\n          address: msg.payload.address,\n          quantity: msg.payload.quantity,\n          emptyMsgOnFail: node.emptyMsgOnFail,\n          keepMsgProperties: node.keepMsgProperties,\n          messageId\n        }\n      }\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg) || !modbusClient.client) {\n        return\n      }\n\n      const origMsgInput = Object.assign({}, msg) // keep it origin\n      try {\n        const inputMsg = node.prepareMsg(origMsgInput)\n        if (node.isValidModbusMsg(inputMsg)) {\n          const newMsg = node.buildNewMessageObject(node, inputMsg)\n          node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\n          modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\n}\n"]}