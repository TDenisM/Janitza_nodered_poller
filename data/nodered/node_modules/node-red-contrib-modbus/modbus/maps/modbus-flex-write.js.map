{"version":3,"sources":["modbus-flex-write.js"],"names":["module","exports","RED","require","install","mbCore","internalDebugLog","nodes","registerType","config","mbBasics","createNode","this","name","showStatusActivities","emptyMsgOnFail","settings","node","keepMsgProperties","getNode","server","bufferMessageList","modbusClient","registerForModbus","onModbusWriteDone","resp","msg","payload","errorProtocolMsg","err","logMsgError","buildMessage","sendEmptyMsgOnFail","message","origMsg","setModbusError","onModbusWriteError","emit","JSON","parse","prepareMsg","parseInt","fc","unitid","address","quantity","isValidModbusMsg","Number","isInteger","isValid","error","Object","setMsgPayloadFromHTTPRequests","value","call","indexOf","messageId","getObjectId","on","origMsgInput","assign","client","httpMsg","newMsg","buildNewMessageObject","set","buildNewMessage","setNodeStatusTo","actualServiceState","deregisterForModbus","clear","id","done","setNodeDefaultStatus"],"mappings":"aAUAA,OAAAC,QAAA,SAAAC,GAEAC,QAAA,sBAAAC,UACAJ,IAAOC,EAAUE,QAAUD,mBACzBG,EAAAF,QAAA,sBAIMG,EAAmBH,QAAQ,QAARA,CAAiB,4BA0J1CD,EAAIK,MAAMC,aAAa,oBAxJvB,SAA0BC,GAJ1BP,EAAMQ,MAAQC,WAAWC,KAAAH,GACzBG,KAAMP,KAASF,EAAQU,KAOrBD,KAAKE,qBAAuBL,EAAOK,qBANrCF,KAAMN,WAAgBG,EAAGN,WAEzBS,KAAAG,eAAAN,EAAAM,eACEb,KAAIK,kBAAJE,EAA2BA,kBAE3BG,KAAKC,iBAALP,EACAM,KAAKE,eAAAA,EAALE,SAAmCF,QAGnC,IAAKC,EAAAA,KACLE,EAAKC,kBAAoBT,IAAAA,IACzBC,EAAKJ,gBAAmBA,UAAAA,GAGxB,IAAMW,EAANf,EAAAK,MAAAY,QAAAV,EAAAW,QACKC,IAOLC,EAAaC,kBAAkBN,GAH/BP,EAAKY,uBAAcL,EAAAK,GAElBL,EAAAO,kBAAA,SAAAC,EAAAC,GAKKT,EAAKH,sBAJXQ,EAAaC,gBAAAA,eAAbN,GAGAA,EAAKO,KAAAA,EAAAA,aAAoBP,EAAUQ,kBAAWC,EAAAC,QAAAF,EAAAC,IAC5CT,EAAIA,KAAKH,4BAQXG,EAAKW,iBAAmB,SAAUC,EAAKH,GAJrCT,EAAAa,YAAiBC,EAAAA,EAAad,GAC9BA,EAAAe,mBAAUf,EAAAY,EAAVH,IAGFT,EAAKW,mBAAmB,SAAUC,EAAKH,GACrChB,EAAAA,iBAAqBO,EAArBgB,SACAvB,EAASsB,EAAAA,mBAATf,EAAAI,kBAAAK,GAFFT,EAAAW,iBAAAC,EAAAK,GASExB,EAASyB,eAAelB,EAAMK,EAAcO,EAAKK,GAJnDjB,EAAKmB,KAAAA,6BAGHnB,EAAAA,WAAKW,SAALF,GAcA,MAbwBT,iBAAfkB,EAAAA,UACTlB,EAAKoB,QAAKC,KAAAC,MAAAb,EAAAC,UAGZV,EAAKuB,QAAAA,GAAaC,SAAUf,EAAVC,QAAee,IAC/BhB,EAAIC,QAAOD,OAAIC,SAAYD,EAAAC,QAAUgB,QACnCjB,EAAAA,QAAIC,QAAeY,SAAUZ,EAAAA,QAA7BiB,SACDlB,EAAAC,QAAAkB,SAAAJ,SAAAf,EAAAC,QAAAkB,UAMMnB,GAFPA,EAAGoB,iBAAmBL,SAASf,GAC/BA,IAAIC,GAAQkB,EAqCZ,OA7CFE,OAAAC,UAAAtB,EAAAC,QAAAe,MAgB8B,IAAnBhB,EAAIC,QAAQe,IAJC,IAAnBI,EAAAA,QAAmBJ,IACtB,KAAIO,EAAUtB,QAAde,IAM6B,KAAnBhB,EAAIC,QAAQe,MAJtBzB,EAAM8B,MAAOC,eAAcrB,GAKzBV,IAAW,IAITgC,GAAAA,OACED,UAASA,EAAAA,QAAaJ,UAGf,GAANM,EAALvB,QAAWiB,SACXK,EAAOtB,QAAPiB,SAAA,QACD3B,EAAAiC,MAAA,oBAAAxB,GADCuB,IAAW,IAQXA,GACDF,OAAAC,UAAAtB,EAAAC,QAAAkB,WAJ+B,GAAxBnB,EAAIC,QAAQkB,UAMbI,EAAAA,QAAPJ,UAAA,QA5BF5B,EAAAiC,MAAA,qBAAAxB,GAyBIuB,IAAW,GAQTE,GAGDlC,EAFDmC,8BAEO,SAAA1B,GAUT,OARMA,OAAIC,UAAQ0B,eAAQC,KAAe3B,EAAAA,QAAf,UAApB,iBAAAD,EAAAC,QAAA0B,QACD,SAAA3B,EAAAC,QAAA0B,OAAA,UAAA3B,EAAAC,QAAA0B,MACF3B,EAAAC,QAAA0B,MAAA,SAAA3B,EAAAC,QAAA0B,OAHuC,EAAlC3B,EAAIC,QAAQ0B,MAAME,QAAQ,OAKlC7B,EAAAC,QAAA0B,MAAAf,KAAAC,MAAAb,EAAAC,QAAA0B,SAIMG,GAGJA,EAAAA,sBAFK,SAAAvC,EAAAS,GAGLC,IAAAA,EAAStB,EAAAoD,cACPJ,MAAAA,CACAV,MAAAA,EAAQjB,OAAIC,EAAQgB,GACpBD,UAAAA,EACAE,QAAO,CACPC,MAAQM,OAAMxB,UAAQkB,eALfS,KAAA5B,EAAAC,QAAA,SAAAD,EAAAC,QAAA0B,MAAA3B,EAAAC,QAMP6B,OAAAA,EAAAA,QAAAA,OANOd,GAAAhB,EAAAC,QAAAe,GAHXE,QAAAlB,EAAAC,QAAAiB,QAFFC,SAAAnB,EAAAC,QAAAkB,SAWMW,UAAAA,KAKNvC,EAAKyC,GAAG,QAAS,SAAUhC,GAKzB,IAAMiC,EAAAA,iBAAsBC,IAAWlC,EAAvCmC,OAAA,CAAMF,EAAeR,OAAOS,OAAO,GAAIlC,GAGrC,IACE,IAEKL,EACLC,EAHMwC,EAAU7C,EAAKmC,WAAAA,GACrBnC,EAAM8C,iBAAcC,KACf3C,EAAAA,EAAAA,8BAAwCX,GAC7CY,EAAae,EAAK2B,sBAAuB/C,EAAKO,GAC/CP,EAAAI,kBAAA4C,IAAAF,EAAAP,UAAA9C,EAAAwD,gBAAAjD,EAAAC,kBAAA4C,EAAAC,IACDzC,EAAYe,KAAA,cAAA0B,EAAA9C,EAAAO,kBAAAP,EAAAmB,qBAEb,MAAAP,GADCZ,EAAKW,iBAAiBC,EAAK8B,GAK5B1C,EAAAH,sBApBHJ,EAAAyD,gBAAA7C,EAAA8C,mBAAAnD,MA0BEK,EAAAA,GAAAA,QAAa+C,SAAAA,GAHf3D,EAAAyD,gBAAA,SAAAlD,GAEEA,EAAKI,kBAAkBiD,QAIzBhD,EAAUR,oBAAsBG,EAAAsD,GAAAC,KAGjCvD,EAAAH,sBAFGJ,EAAS+D,qBAAqBxD","file":"../modbus-flex-write.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n/**\n * Modbus flexible Write node.\n * @module NodeRedModbusFlexWrite\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const internalDebugLog = require('debug')('contribModbus:flex:write')\n\n  function ModbusFlexWrite (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n    node.bufferMessageList = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusWriteDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('writing done', node)\n      }\n\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\n      node.emit('modbusFlexWriteNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      mbBasics.logMsgError(node, err, msg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n    }\n\n    node.onModbusWriteError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusFlexWriteNodeError')\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg.payload === 'string') {\n        msg.payload = JSON.parse(msg.payload)\n      }\n\n      msg.payload.fc = parseInt(msg.payload.fc)\n      msg.payload.unitid = parseInt(msg.payload.unitid)\n      msg.payload.address = parseInt(msg.payload.address)\n      msg.payload.quantity = parseInt(msg.payload.quantity)\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.payload.fc) &&\n              (msg.payload.fc === 5 ||\n                msg.payload.fc === 6 ||\n                msg.payload.fc === 15 ||\n                msg.payload.fc === 16))) {\n        node.error('FC Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.address) &&\n              msg.payload.address >= 0 &&\n              msg.payload.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n            !(Number.isInteger(msg.payload.quantity) &&\n              msg.payload.quantity >= 1 &&\n              msg.payload.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.setMsgPayloadFromHTTPRequests = function (msg) {\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\n      if (Object.prototype.hasOwnProperty.call(msg.payload, 'value') && typeof msg.payload.value === 'string') {\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\n          msg.payload.value = (msg.payload.value === 'true')\n        } else {\n          if (msg.payload.value.indexOf(',') > -1) {\n            msg.payload.value = JSON.parse(msg.payload.value)\n          }\n        }\n      }\n      return msg\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          value: (Object.prototype.hasOwnProperty.call(msg.payload, 'value')) ? msg.payload.value : msg.payload,\n          unitid: msg.payload.unitid,\n          fc: msg.payload.fc,\n          address: msg.payload.address,\n          quantity: msg.payload.quantity,\n          messageId\n        }\n      }\n    }\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg) || !modbusClient.client) {\n        return\n      }\n\n      const origMsgInput = Object.assign({}, msg)\n      try {\n        const inputMsg = node.prepareMsg(origMsgInput)\n        if (node.isValidModbusMsg(inputMsg)) {\n          const httpMsg = node.setMsgPayloadFromHTTPRequests(inputMsg)\n          const newMsg = node.buildNewMessageObject(node, httpMsg)\n          node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, httpMsg, newMsg))\n          modbusClient.emit('writeModbus', newMsg, node.onModbusWriteDone, node.onModbusWriteError)\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-write', ModbusFlexWrite)\n}\n"]}