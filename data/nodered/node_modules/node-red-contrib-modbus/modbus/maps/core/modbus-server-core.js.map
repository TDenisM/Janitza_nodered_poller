{"version":3,"sources":["core/modbus-server-core.js"],"names":["require","install","de","biancoroyal","modbus","core","server","internalDebug","bufferFactor","memoryTypes","memoryUint16Types","memoryUint8Types","getLogFunction","node","internalDebugLog","msg","payload","Number","address","copyToModbusFlexBuffer","register","copy","bufferSplitAddress","bufferData","registers","coils","writeToModbusFlexBuffer","writeUInt16BE","bufferPayload","writeUInt8","bufferAddress","writeModbusFlexServerMemory","coreServer","splitAddress","parseInt","convertInputForBufferWrite","isMultipleWrite","value","length","Uint8Array","Buffer","copyToModbusBuffer","modbusServer","holding","alloc","buffer","wasMultipleWrite","input","discrete","writeModbusServerMemory","writeToModbusBuffer","writeToServerMemory","toLowerCase","includes","error","err","writeToFlexServerMemory","module","exports"],"mappings":"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","file":"../../core/modbus-server-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { core: { server: { } } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.core.server.internalDebug = de.biancoroyal.modbus.core.server.internalDebug || require('debug')('contribModbus:core:server') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.core.server.bufferFactor = 8\nde.biancoroyal.modbus.core.server.memoryTypes = ['holding', 'coils', 'input', 'discrete']\nde.biancoroyal.modbus.core.server.memoryUint16Types = ['holding', 'input']\nde.biancoroyal.modbus.core.server.memoryUint8Types = ['coils', 'discrete']\n\nde.biancoroyal.modbus.core.server.getLogFunction = function (node) {\n  if (node.internalDebugLog) {\n    return node.internalDebugLog\n  } else {\n    return de.biancoroyal.modbus.core.server.internalDebug\n  }\n}\n\nde.biancoroyal.modbus.core.server.isValidMemoryMessage = function (msg) {\n  return msg.payload &&\n    msg.payload.register &&\n    Number.isInteger(msg.payload.address) &&\n    msg.payload.address >= 0 &&\n    msg.payload.address <= 65535\n}\n\nde.biancoroyal.modbus.core.server.copyToModbusFlexBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      msg.bufferData.copy(node.registers, msg.bufferSplitAddress)\n      break\n    case 'coils':\n      msg.bufferData.copy(node.coils, msg.bufferAddress)\n      break\n    case 'input':\n      msg.bufferData.copy(node.registers, msg.bufferAddress)\n      break\n    case 'discrete':\n      msg.bufferData.copy(node.coils, msg.bufferSplitAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\n\nde.biancoroyal.modbus.core.server.writeToModbusFlexBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      node.registers.writeUInt16BE(msg.bufferPayload, msg.bufferSplitAddress)\n      break\n    case 'coils':\n      node.coils.writeUInt8(msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'input':\n      node.registers.writeUInt16BE(msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'discrete':\n      node.coils.writeUInt8(msg.bufferPayload, msg.bufferSplitAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\n\nde.biancoroyal.modbus.core.server.writeModbusFlexServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.bufferSplitAddress = (parseInt(msg.payload.address) + parseInt(node.splitAddress)) * coreServer.bufferFactor\n  msg.bufferAddress = parseInt(msg.payload.address) * coreServer.bufferFactor\n\n  if (coreServer.convertInputForBufferWrite(msg)) {\n    return coreServer.copyToModbusFlexBuffer(node, msg)\n  } else {\n    return coreServer.writeToModbusFlexBuffer(node, msg)\n  }\n}\n\nde.biancoroyal.modbus.core.server.convertInputForBufferWrite = function (msg) {\n  let isMultipleWrite = false\n  if (msg.payload.value.length) {\n    msg.bufferPayload = new Uint8Array(msg.payload.value)\n    msg.bufferData = Buffer.alloc(msg.bufferPayload.buffer.byteLength, msg.bufferPayload)\n    isMultipleWrite = true\n    msg.wasMultipleWrite = true\n  } else {\n    msg.bufferPayload = parseInt(msg.payload.value)\n    msg.wasMultipleWrite = false\n  }\n\n  return isMultipleWrite\n}\n\nde.biancoroyal.modbus.core.server.copyToModbusBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      msg.bufferData.copy(node.modbusServer.holding, msg.bufferAddress)\n      break\n    case 'coils':\n      msg.bufferData.copy(node.modbusServer.coils, msg.bufferAddress)\n      break\n    case 'input':\n      msg.bufferData.copy(node.modbusServer.input, msg.bufferAddress)\n      break\n    case 'discrete':\n      msg.bufferData.copy(node.modbusServer.discrete, msg.bufferAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\n\nde.biancoroyal.modbus.core.server.writeToModbusBuffer = function (node, msg) {\n  switch (msg.payload.register) {\n    case 'holding':\n      node.modbusServer.holding.writeUInt16BE(msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'coils':\n      node.modbusServer.coils.writeUInt8(msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'input':\n      node.modbusServer.input.writeUInt16BE(msg.bufferPayload, msg.bufferAddress)\n      break\n    case 'discrete':\n      node.modbusServer.discrete.writeUInt8(msg.bufferPayload, msg.bufferAddress)\n      break\n    default:\n      return false\n  }\n  return true\n}\nde.biancoroyal.modbus.core.server.writeModbusServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.bufferAddress = parseInt(msg.payload.address) * coreServer.bufferFactor\n\n  if (coreServer.convertInputForBufferWrite(msg)) {\n    return coreServer.copyToModbusBuffer(node, msg)\n  } else {\n    return coreServer.writeToModbusBuffer(node, msg)\n  }\n}\n\nde.biancoroyal.modbus.core.server.writeToServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.payload.register = msg.payload.register.toLowerCase()\n  try {\n    if (coreServer.memoryTypes.includes(msg.payload.register)) {\n      coreServer.writeModbusServerMemory(node, msg)\n    }\n  } catch (err) {\n    msg.error = err\n    node.error(err)\n  }\n}\n\nde.biancoroyal.modbus.core.server.writeToFlexServerMemory = function (node, msg) {\n  const coreServer = de.biancoroyal.modbus.core.server\n  msg.payload.register = msg.payload.register.toLowerCase()\n  try {\n    if (coreServer.memoryTypes.includes(msg.payload.register)) {\n      coreServer.writeModbusFlexServerMemory(node, msg)\n    }\n  } catch (err) {\n    msg.error = err\n    node.error(err)\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.core.server\n"]}