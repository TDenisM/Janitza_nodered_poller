{"version":3,"sources":["core/modbus-queue-core.js"],"names":["require","install","de","biancoroyal","modbus","queue","core","internalDebug","initQueue","node","clear","sendingAllowed","unitSendingAllowed","step","bufferCommandList","set","queuesAreEmpty","get","length","queueSerialUnlockCommand","this","name","serialSendingAllowed","queueSerialLockCommand","sequentialDequeueCommand","Promise","resolve","parallelUnitIdsAllowed","unitId","shift","Error","queueLog","JSON","stringify","queueCore","sendQueueDataToModbus","isValidUnitId","reject","warn","infoText","type","queueLength","command","callModbus","msg","cb","cberr","dequeueLogEntry","state","info","actualServiceState","then","err","message","delay","commandDelay","parseInt","payload","unitid","unit_id","dequeueCommand","messageAllowedStates","indexOf","pushToQueueByUnitId","coreQueue","getUnitIdToQueue","getQueueLengthByUnitId","queueUnitId","clienttype","push"],"mappings":"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","file":"../../core/modbus-queue-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020 Klaus Landsdorf (https://bianco-royal.com/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { queue: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.internalDebug = de.biancoroyal.modbus.queue.core.internalDebug || require('debug')('contribModbus:queue:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.core = de.biancoroyal.modbus.queue.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.queue.core.initQueue = function (node) {\n  node.bufferCommandList.clear()\n  node.sendingAllowed.clear()\n  node.unitSendingAllowed = []\n\n  for (let step = 0; step <= 255; step++) {\n    node.bufferCommandList.set(step, [])\n    node.sendingAllowed.set(step, true)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.checkQueuesAreEmpty = function (node) {\n  let queuesAreEmpty = true\n  for (let step = 0; step <= 255; step++) {\n    queuesAreEmpty &= (node.bufferCommandList.get(step).length === 0)\n  }\n  return queuesAreEmpty\n}\n\nde.biancoroyal.modbus.queue.core.queueSerialUnlockCommand = function (node) {\n  this.internalDebug('queue serial unlock command node ' + node.name)\n  node.serialSendingAllowed = true\n}\n\nde.biancoroyal.modbus.queue.core.queueSerialLockCommand = function (node) {\n  this.internalDebug('queue serial lock command node ' + node.name)\n  node.serialSendingAllowed = false\n}\n\nde.biancoroyal.modbus.queue.core.sequentialDequeueCommand = function (node) {\n  this.internalDebug('sequential de-queue command')\n  return new Promise(\n    function (resolve, reject) {\n      const queueCore = de.biancoroyal.modbus.queue.core\n\n      if (node.parallelUnitIdsAllowed) {\n        for (let unitId = 0; unitId < 256; unitId += 1) {\n          queueCore.sendQueueDataToModbus(node, unitId)\n        }\n      } else {\n        const unitId = node.unitSendingAllowed.shift()\n        if (!unitId) {\n          reject(new Error('UnitId is valid from sending allowed list'))\n          return\n        }\n\n        node.queueLog(JSON.stringify({\n          type: 'sequential dequeue command',\n          unitId,\n          isValidUnitId: queueCore.isValidUnitId(unitId),\n          sendingAllowed: node.sendingAllowed.get(unitId),\n          serialSendingAllowed: node.serialSendingAllowed\n        }))\n\n        if (queueCore.isValidUnitId(unitId) &&\n          node.sendingAllowed.get(unitId)) {\n          queueCore.sendQueueDataToModbus(node, unitId)\n        } else {\n          node.warn('sequential dequeue command not possible for Unit ' + unitId)\n          let infoText = 'sending is allowed for Unit '\n          if (node.sendingAllowed.get(unitId)) {\n            node.warn(infoText + unitId)\n          } else {\n            node.warn('no ' + infoText + unitId)\n          }\n          infoText = 'valid  Unit '\n          if (queueCore.isValidUnitId(unitId)) {\n            node.warn(infoText + unitId)\n          } else {\n            node.warn('no ' + infoText + unitId)\n          }\n          infoText = ' serial sending allowed for Unit '\n          if (node.serialSendingAllowed) {\n            node.warn(node.name + infoText + unitId)\n          } else {\n            node.warn(node.name + ' no' + infoText + unitId)\n          }\n        }\n      }\n      resolve()\n    })\n}\n\nde.biancoroyal.modbus.queue.core.sendQueueDataToModbus = function (node, unitId) {\n  const queueLength = node.bufferCommandList.get(unitId).length\n  node.queueLog(JSON.stringify({\n    type: 'send queue data to Modbus',\n    unitId,\n    queueLength,\n    sendingAllowed: node.sendingAllowed.get(unitId),\n    serialSendingAllowed: node.serialSendingAllowed\n  }))\n\n  if (queueLength) {\n    const command = node.bufferCommandList.get(unitId).shift()\n    if (command) {\n      node.sendingAllowed.set(unitId, false)\n      command.callModbus(node, command.msg, command.cb, command.cberr)\n    } else {\n      throw new Error('Command On Send Not Valid')\n    }\n  }\n}\n\nde.biancoroyal.modbus.queue.core.dequeueLogEntry = function (node, state, info) {\n  node.queueLog(JSON.stringify({\n    state: state.value,\n    message: `${info} ${node.clienttype}`,\n    delay: node.commandDelay\n  }))\n}\n\nde.biancoroyal.modbus.queue.core.dequeueCommand = function (node) {\n  const queueCore = de.biancoroyal.modbus.queue.core\n  const state = node.actualServiceState\n\n  if (node.messageAllowedStates.indexOf(state.value) === -1) {\n    queueCore.dequeueLogEntry(node, state, 'dequeue command disallowed state')\n  } else {\n    queueCore.sequentialDequeueCommand(node).then(function () {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command done')\n    }).catch(function (err) {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command error ' + err.message)\n    })\n  }\n}\n\nde.biancoroyal.modbus.queue.core.getUnitIdToQueue = function (node, msg) {\n  return parseInt(msg.payload.unitid) || parseInt(node.unit_id) || 0\n}\n\nde.biancoroyal.modbus.queue.core.isValidUnitId = function (unitId) {\n  return (unitId >= 0 || unitId <= 255)\n}\n\nde.biancoroyal.modbus.queue.core.getQueueLengthByUnitId = function (node, unitId) {\n  if (this.isValidUnitId(unitId)) {\n    return node.bufferCommandList.get(unitId).length\n  } else {\n    throw new Error('(0-255) Got A Wrong Unit-Id: ' + unitId)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.pushToQueueByUnitId = function (node, callModbus, msg, cb, cberr) {\n  const coreQueue = de.biancoroyal.modbus.queue.core\n\n  return new Promise(\n    function (resolve, reject) {\n      try {\n        const unitId = coreQueue.getUnitIdToQueue(node, msg)\n        if (!unitId) {\n          reject(new Error('UnitId is valid from msg or node'))\n          return\n        }\n        const queueLength = coreQueue.getQueueLengthByUnitId(node, unitId)\n\n        msg.queueLengthByUnitId = { unitId, queueLength }\n        msg.queueUnitId = unitId\n\n        if (!node.parallelUnitIdsAllowed || node.clienttype === 'serial') {\n          node.unitSendingAllowed.push(unitId)\n        }\n\n        node.bufferCommandList.get(unitId).push({ callModbus: callModbus, msg: msg, cb: cb, cberr: cberr })\n        node.queueLog(JSON.stringify({\n          info: 'pushed to Queue by Unit-Id',\n          message: msg.payload,\n          unitId\n        }))\n        resolve()\n      } catch (err) {\n        reject(err)\n      }\n    })\n}\n\nmodule.exports = de.biancoroyal.modbus.queue.core\n"]}